[{"id":0,"title":"","routePath":"/blog/1.python/advanced/网络编程","lang":"","toc":[{"text":"网络编程","id":"网络编程","depth":2,"charIndex":-1}],"domain":"","content":"网络编程#","frontmatter":{},"version":""},{"id":1,"title":"","routePath":"/blog/1.python/basic/数据类型","lang":"","toc":[{"text":"数据类型","id":"数据类型","depth":2,"charIndex":-1}],"domain":"","content":"数据类型#","frontmatter":{},"version":""},{"id":2,"title":"","routePath":"/blog/1.python/","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":3,"title":"","routePath":"/blog/2.fastapi/","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":4,"title":"","routePath":"/blog/3.mysql/","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":5,"title":"","routePath":"/blog/4.linux/","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":7,"title":"","routePath":"/blog/随笔/python/1.project","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":8,"title":"","routePath":"/blog/随笔/python/2.excel-action","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":9,"title":"","routePath":"/blog/随笔/python/3.po","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":10,"title":"","routePath":"/blog/随笔/utils/charles","lang":"","toc":[{"text":"介绍、安装及破解","id":"介绍安装及破解","depth":2,"charIndex":-1},{"text":"SSL 配置与证书安装","id":"ssl-配置与证书安装","depth":2,"charIndex":246},{"text":"SSL 配置","id":"ssl-配置","depth":3,"charIndex":340},{"text":"证书安装","id":"证书安装","depth":3,"charIndex":551},{"text":"Chrome 抓包","id":"chrome-抓包","depth":2,"charIndex":669},{"text":"Mobile 抓包","id":"mobile-抓包","depth":2,"charIndex":925},{"text":"Android","id":"android","depth":3,"charIndex":1007},{"text":"iPhone","id":"iphone","depth":3,"charIndex":1399},{"text":"模拟网络延迟（弱网测试）","id":"模拟网络延迟弱网测试","depth":2,"charIndex":1526},{"text":"篡改请求信息","id":"篡改请求信息","depth":2,"charIndex":1615},{"text":"Compose","id":"compose","depth":3,"charIndex":1665},{"text":"Rewrite","id":"rewrite","depth":3,"charIndex":1780},{"text":"BreakPoint","id":"breakpoint","depth":3,"charIndex":1899}],"domain":"","content":"介绍、安装及破解#\n\nCharles 是 http 代理工具。可以监控机器与互联网通信的过程，拿到其通信数据。在移动端的开发及测试领域尝尝能看到它的身影。安装地址\n\n注：后续所有内容均以 mac 系统为例\n\n需要注意的是 Charles 是付费软件，下载后可免费使用 30 天。付费地址\n\n如果你囊中羞涩，可以考虑使用破解版。破解地址\n\n破解方式为：导航栏中 Help -> Registered to charles 输入对应的内容即出现如下提示，告诉你注册成功，关闭重新启动一下。\n\n\n\n\nSSL 配置与证书安装#\n\n默认情况下 Charles 之后拦截 http 的请求，对于加密请求无法进行拦截。这时就需要修改 Charles的配置以及添加证书让其对加密请求进行支持。\n\n\nSSL 配置#\n\n配置 Proxy 分为三步\n\n * 导航栏中 Proxy -> SSL Proxy Settings 增加如下配置；配置 SSL 相关的内容。\n\n\n\n * 导航栏中 Proxy -> Proxy Settings 增加如下配置；配置关于协议的内容。\n\n\n\n * 导航栏中 Proxy -> Recording Settings 增加如下配置；只有匹配下面的内容才会被记录在 Charles 中。\n\n\n\n\n证书安装#\n\n导航栏中 Help -> SSL Proxying -> Install Charles Root Certificate 点击后会弹出钥匙串，在钥匙串中搜索\nCharles Proxy CA 点击证书选择使用信任。\n\n\nChrome 抓包#\n\nChrome 需要安装 SwitchyOmega 插件。插件地址\n\nSwitchyOmega 可以帮助用户管理和切换代理。具体使用方法不在本文中赘述，只演示如何配置及关键性操作。\n\n新增名为 Charles 的情景模式，并配置如下内容：\n\n\n\n在 auto switch 中添加条件，并且将情景模式选择为 Charles，然后点击应用选项。具体效果如下：\n\n\n\n最后开启插件启用规则 Charles 或 auto switch 再开启抓包工具即可完成浏览器的抓包。具体效果如下：\n\n\n\n\nMobile 抓包#\n\n移动端的抓包整体需要两步配置：\n\n * 移动端需要安装证书\n * 保证 PC 与 Mobile 处于同一网段下（连接同一个 WIFI）\n\n\nAndroid#\n\nAndroid 7.0 之后 Google 推出了更加严格的安全机制，默认不信任用户的安装的证书，这也导致了对于 https 加密的请求，不再可以抓取了。\n\n解决方案主流的大致分为两种：\n\n * 既然不支持用户的 CA 证书，可以安装系统级别 CA 证书，但前提设备必须为 root 模式。\n * 如果是自己公司研发的产品可以在 AndroidManifest 中配置 networkSecurityConfig 具体不再这里演示。\n\n以小米手机为例进行抓包配置，示例如下：\n\n\n\n打开手机浏览器输入 chls.pro/ssl 即会下载 CA 证书，下载完成后进行安装即可。\n\n如果手机浏览器失败可以尝试使用 PC 重复次操作即会得到 charles-proxy-ssl-proxying-certificate.pem\n证书，将此证书传入手机进行安装即可。\n\n\niPhone#\n\niPhone 的抓包与 android 基本类似，打开 Charles 保存在同一局域网下，先设置手机的代理，具体配置如下：\n\n\n\nSafari 中输入内容 chls.pro/ssl 下载安装证书，最后在关于本机中信任此证书即可。\n\n\n模拟网络延迟（弱网测试）#\n\n导航栏中 Throttle Settings 点击后出现窗口，开启后使用预设配置或者自定义配置，点击 ok 即开启网络模拟。具体效果如下：\n\n\n\n\n篡改请求信息#\n\n修改请求的方式分为三种，Compose、Rewrite、BreakPoint\n\n\nCompose#\n\n该方法只能只能修改 url、method、params。作用域仅限于 Charles 中，修改后即会重新发送一个请求，用来验证结果。\n\n选中指定的请求，右键 -> Compose，具体使用及效果如下：\n\n\n\n\nRewrite#\n\n该方法除了 Request Body 不能修改，其余都支持修改。该配置开启后，后续被代理宿主机的任何请求只要符合该条件都会被修改。\n\n导航栏 Tools -> Rewrite Settings，配置窗口如下：\n\n\n\n\nBreakPoint#\n\n该方法值比较主流的修改请求方案，效果为拦截请求的响应，当你修改后再去给请求放行，不过页面有可能因为请求一直得不到回复导致崩溃。\n\n选中指定请求，右键 -> Breakpoints 即开启断点，每次经过这个请求就会进行拦截。关闭断点的方式则需要点击 工具栏中的六边形 效果如下：\n\n\n\n一个 http 请求共需要放行四次，分别为 Request Header、Request Body、Response Header、Response\nBody；内容可以直接进行修改。\n\n注意： 直接右键是严格匹配的断点，如果请求每次参数都会变化，很可能会导致无法命中断点。在导航栏 Proxy -> Breakpoints Settings\n中可以针对断点进行配置。\n\n","frontmatter":{},"version":""},{"id":11,"title":"","routePath":"/blog/随笔/utils/curl","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":12,"title":"","routePath":"/blog/随笔/utils/禅道","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":13,"title":"","routePath":"/blog/面试/interview/1.软件测试理论基石","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":14,"title":"","routePath":"/blog/面试/interview/2.计算机网络","lang":"","toc":[{"text":"HTTP 和 HTTPS 的基本概念","id":"http-和-https-的基本概念","depth":2,"charIndex":-1},{"text":"HTTP 和 HTTPS 的区别及优缺点？","id":"http-和-https-的区别及优缺点","depth":2,"charIndex":166},{"text":"HTTPS 协议的工作原理","id":"https-协议的工作原理","depth":2,"charIndex":557},{"text":"HTTP 请求跨域问题","id":"http-请求跨域问题","depth":2,"charIndex":865},{"text":"HTTP 1.1 和 HTTP 2.0 的区别","id":"http-11-和-http-20-的区别","depth":2,"charIndex":1534},{"text":"为什么 HTTP1.1 不能实现多路复用","id":"为什么-http11-不能实现多路复用","depth":2,"charIndex":2420},{"text":"HTTP 和 HTTPS 协议的区别","id":"http-和-https-协议的区别","depth":2,"charIndex":2561},{"text":"GET 和 POST 的请求的区别","id":"get-和-post-的请求的区别","depth":2,"charIndex":2823},{"text":"常见的 HTTP 请求头和响应头","id":"常见的-http-请求头和响应头","depth":2,"charIndex":3272},{"text":"HTTP Request Header 常见的请求头：","id":"http-request-header-常见的请求头","depth":3,"charIndex":3292},{"text":"HTTP Responses Header 常见的响应头：","id":"http-responses-header-常见的响应头","depth":3,"charIndex":3565},{"text":"常见的 Content-Type 属性值有以下四种：","id":"常见的-content-type-属性值有以下四种","depth":3,"charIndex":3739},{"text":"HTTP 状态码 304 是多好还是少好","id":"http-状态码-304-是多好还是少好","depth":2,"charIndex":4124},{"text":"OPTIONS 请求方法及使用场景","id":"options-请求方法及使用场景","depth":2,"charIndex":4386},{"text":"TCP 三次握手","id":"tcp-三次握手","depth":2,"charIndex":4513},{"text":"为什么要三次握手","id":"为什么要三次握手","depth":3,"charIndex":4845},{"text":"TCP 四次挥手","id":"tcp-四次挥手","depth":2,"charIndex":5163},{"text":"为什么建立连接握手三次，关闭连接时需要是四次呢？","id":"为什么建立连接握手三次关闭连接时需要是四次呢","depth":3,"charIndex":5696},{"text":"TCP/IP 如何保证数据包传输的有序可靠？","id":"tcpip-如何保证数据包传输的有序可靠","depth":2,"charIndex":5973},{"text":"TCP 和 UDP 的区别","id":"tcp-和-udp-的区别","depth":2,"charIndex":6306},{"text":"DNS 完整的查询过程","id":"dns-完整的查询过程","depth":2,"charIndex":6533}],"domain":"","content":"HTTP 和 HTTPS 的基本概念#\n\nhttp: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。\n\nhttps:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\n\n\nHTTP 和 HTTPS 的区别及优缺点？#\n\n * http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl\n   加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。\n * http 协议的默认端口为 80，https 的默认端口为 443。\n * http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\n * https 缓存不如 http 高效，会增加数据开销。\n * Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。\n * SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。\n\n\nHTTPS 协议的工作原理#\n\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：\n\n 1. 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。\n 2. web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。\n 3. 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。\n 4. 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。\n 5. web 服务器通过自己的私钥解密出会话密钥。\n 6. web 服务器通过会话密钥加密与客户端之间的通信。\n\n\nHTTP 请求跨域问题#\n\n跨域的原理\n\n跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。 同源策略,是浏览器对 JavaScript\n实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。 跨域原理，即是通过各种方式，避开浏览器的安全限制。\n\n解决方案\n\n * JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js\n   脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。JSONP\n   的缺点: JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。\n\n * document.domain 基础域名相同 子域名不同\n\n * window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name\n\n * CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对 CORS\n   的支持原理：服务器设置Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求\n\n * proxy 代理 目前常用方式,通过服务器设置代理\n\n * window.postMessage() 利用 h5 新特性 window.postMessage()\n\n\nHTTP 1.1 和 HTTP 2.0 的区别#\n\n二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文 的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是\n二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是 二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念 是它实现多路复用的基础\n\n多路复用：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接， 但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，\n而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"的问题。 数据流：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不\n按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。 因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每\n个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个 独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分 它属于哪个数据流。\n\n头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带 状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重 复的，比如\nCookie 和 User Agent ，一模一样的内容，每次请求都 必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了\n优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张\n头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发 送同样字段了，只发送索引号，这样就能提高速度了。\n\n服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源， 这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，\n这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服 务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向\n客户端发送即时数据的推送是不同的。\n\n\n为什么 HTTP1.1 不能实现多路复用#\n\nHTTP/1.1\n不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将\n多个响应的结果重新进行组装，也就实现不了多路复用。\n\n\nHTTP 和 HTTPS 协议的区别#\n\nHTTP 和 HTTPS 协议的主要区别如下： HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要； HTTP\n协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安 全性的 SSL 加密传输协议； 使用不同的连接方式，端口也不同，HTTP 协议端口是\n80，HTTPS 协 议端口是 443； HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协\n议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全。\n\n\nGET 和 POST 的请求的区别#\n\nPost 和 Get 是 HTTP 请求的两种方法，其区别如下： 应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务\n器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比 如注册用户这一类的操作。\n是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存， 但很少对 Post 请求缓存。\n\n发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报 文中实体部分一般为向服务器发送的数据。 安全性：Get 请求可以将请求的参数放入 url\n中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会 被保留在历史记录中。 请求长度：浏览器由于对 url\n长度的限制，所以会影响 get 请求发 送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。 参数类型：post 的参数传递支持更多的数据类型。\n\n\n常见的 HTTP 请求头和响应头#\n\n\nHTTP Request Header 常见的请求头：#\n\n * Accept:浏览器能够处理的内容类型\n * Accept-Charset:浏览器能够显示的字符集\n * Accept-Encoding：浏览器能够处理的压缩编码\n * Accept-Language：浏览器当前设置的语言\n * Connection：浏览器与服务器之间连接的类型\n * Cookie：当前页面设置的任何 Cookie\n * Host：发出请求的页面所在的域\n * Referer：发出请求的页面的 URL\n * User-Agent：浏览器的用户代理字符串\n\n\nHTTP Responses Header 常见的响应头：#\n\n * Date：表示消息发送的时间，时间的描述格式由 rfc822 定义 server:服务器名称\n * Connection：浏览器与服务器之间连接的类型\n * Cache-Control：控制 HTTP 缓存 content-type:表示后面的文档属于什么 MIME 类型\n\n\n常见的 Content-Type 属性值有以下四种：#\n\n 1. application/x-www-form-urlencoded：浏览器的原生 form 表单 ， 如果不设置 contentype 属性 ，\n    那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照\n    key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。\n 2. multipart/form-data：该种方式也是一个常见的 POST 提交方 式，通常表单上传文件时使用该种方式。\n 3. application/json：服务器消息主体是序列化后的 JSON 字符串。\n 4. text/xml：该种方式主要用来提交 XML 格式的数据。\n\n\nHTTP 状态码 304 是多好还是少好#\n\n状态码 304 不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。\n\n搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于 304\n的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n\n产生过 304 的原因是 页面更新周期长或不更新\n\n过多的 304 会造成 网站快照停止；收录减少；权重下降。\n\n\nOPTIONS 请求方法及使用场景#\n\n * 获取服务器支持的所有 HTTP 请求方法；\n\n * 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n\nTCP 三次握手#\n\n\n\n 1. 第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT\n    状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n 2. 第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即 SYN+ACK\n    包，此时服务器进入 SYN_RECV 状态；\n 3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入\n    ESTABLISHED（TCP 连接成功）状态，完成三次握手。\n\n\n为什么要三次握手#\n\nTCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。\n\n 1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n\n 2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接\n    收能力是否正常。\n\n 3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n所以，只有三次握手才能确认双方的接收与发送能力是否正常。\n\n淘宝二面三次握手、四次挥手\n\n\nTCP 四次挥手#\n\n\n\n第一次挥手。客户端发起 FIN 包（FIN = 1）,客户端进入 FIN_WAIT_1 状态。TCP 规定，即使 FIN 包不携带数据，也要消耗一个序号。\n\n第二次挥手。服务器端收到 FIN 包，发出确认包 ACK（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 CLOSE_WAIT\n状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 FIN_WAIT_2\n状态。\n\n第三次挥手。服务器端数据发送完毕后，向客户端发送 FIN 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为\nw。服务器此时进入了 LAST_ACK 状态。\n\n第四次挥手。客户端收到服务器的 FIN 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 TIME_WAIT 状态。注意此时 TCP\n连接还没有释放，必须经过 2*MSL 后，才进入 CLOSED 状态。而服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态，可以看出服务器端结束\nTCP 连接的时间要比客户端早一些。\n\n\n为什么建立连接握手三次，关闭连接时需要是四次呢？#\n\n其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。\n\n对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN\n包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认\nACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。\n\n淘宝二面三次握手、四次挥手\n\n\nTCP/IP 如何保证数据包传输的有序可靠？#\n\n对字节流分段并进行编号然后通过  ACK 回复和超时重发这两个机制来保证。\n\n（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；\n\n（2）并为每个已发送的数据包启动一个超时定时器；\n\n（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;\n\n（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。\n\n（5）接收方收到数据包后，先进行 CRC\n校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。\n\n\nTCP 和 UDP 的区别#\n\n * TCP 是面向链接的，而 UDP 是面向无连接的。\n * TCP 仅支持单播传输，UDP 提供了单播，多播，广播的功能。\n * TCP 的三次握手保证了连接的可靠性; UDP\n   是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。\n * UDP 的头部开销比 TCP 的更小，数据传输速率更高，实时性更好。\n\n\nDNS 完整的查询过程#\n\n 1. 首先会在浏览器的缓存中查找对应的 IP 地址，如果查找到直接返回；\n 2. 若找不到继续下一步 将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，\n 3. 若找不到继续下一步 本地 DNS 服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址本地 DNS\n    服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，:one: 如果有记录，就返回查询结果，:two:\n    如果没有就返回相关的下一级的权威域名服务器的地址本地 DNS 服务器向权威域名服务器发送请求，域名服务器返回对应的 结果本地 DNS\n    服务器将返回结果保存在缓存中，便于下次使用本地 DNS 服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 IP 地址\n\n 1. 首先会在浏览器的缓存中 查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，\n 2. 如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。\n 3. 然后本地 DNS 服务器再向其 中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶 级域名服务器返回负责 .baidu\n    的权威域名服务器的 IP 地址列表。\n 4. 然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，\n 5. 最后权威域名服务器返回一个对应的主机名的 IP 地址列表。","frontmatter":{"layout":"doc"},"version":""},{"id":15,"title":"","routePath":"/blog/面试/interview/3.python基础","lang":"","toc":[],"domain":"","content":"","frontmatter":{},"version":""},{"id":16,"title":"","routePath":"/blog/面试/interview/4.浏览器相关","lang":"","toc":[{"text":"点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址 栏回车有什么区别","id":"点击刷新按钮或者按-f5按-ctrlf5-强制刷新地址-栏回车有什么区别","depth":2,"charIndex":-1},{"text":"什么是 XSS 攻击","id":"什么是-xss-攻击","depth":2,"charIndex":316},{"text":"概念","id":"概念","depth":3,"charIndex":330},{"text":"攻击类型","id":"攻击类型","depth":3,"charIndex":614},{"text":"存储型 XSS 的攻击步骤：","id":"存储型-xss-的攻击步骤","depth":4,"charIndex":837},{"text":"反射型 XSS 的攻击步骤：","id":"反射型-xss-的攻击步骤","depth":4,"charIndex":1060},{"text":"DOM 型 XSS 的攻击步骤：","id":"dom-型-xss-的攻击步骤","depth":4,"charIndex":1423},{"text":"如何防御 XSS 攻击","id":"如何防御-xss-攻击","depth":2,"charIndex":1702},{"text":"什么是 CSRF 攻击","id":"什么是-csrf-攻击","depth":2,"charIndex":2000},{"text":"概念","id":"概念-1","depth":3,"charIndex":2015},{"text":"攻击类型","id":"攻击类型-1","depth":3,"charIndex":2192},{"text":"如何防御 CSRF 攻击","id":"如何防御-csrf-攻击","depth":2,"charIndex":2373},{"text":"SQL注入有哪几种注入类型？","id":"sql注入有哪几种注入类型","depth":2,"charIndex":3413}],"domain":"","content":"点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址 栏回车有什么区别#\n\n * 点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是 会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对\n   文件检查新鲜度，返回结果可能是 304，也有可能是 200。\n * 用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且 不会带上\n   If-Modifed-Since，If-None-Match，相当于之前从来没有 请求过，返回结果是 200。\n * 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期， 然后服务器检查新鲜度，最后返回内容。\n\n\n什么是 XSS 攻击#\n\n\n概念#\n\nXSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。\n\nXSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。\n\n攻击者可以通过这种攻击方式可以进行以下操作：\n\n * 获取页面的数据，如 DOM、cookie、localStorage；\n * DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；\n * 破坏页面结构；\n * 流量劫持（将链接指向某网站）；\n\n\n攻击类型#\n\nXSS 可以分为存储型、反射型和 DOM 型：\n\n * 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。\n * 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS\n   代码的数据后当做脚本执行，最终完成 XSS 攻击。\n * DOM 型指的通过修改页面的 DOM 节点形成的 XSS。\n\n存储型 XSS 的攻击步骤：#\n\n 1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。\n 2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n\n反射型 XSS 的攻击步骤：#\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\n\n反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL\n才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\n\nDOM 型 XSS 的攻击步骤：\n\nDOM 型 XSS 的攻击步骤：#\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 URL。\n 3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端 JavaScript\n⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。\n\n\n如何防御 XSS 攻击#\n\n * 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML\n   中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。\n * 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\n * 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n\n\n什么是 CSRF 攻击#\n\n\n概念#\n\nCSRF\n攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个\n登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\n\nCSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。\n\n\n攻击类型#\n\n * GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\n * POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。\n * 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。\n\n\n如何防御 CSRF 攻击#\n\n * 进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin\n   或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer\n   可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer\n   字段会告诉服务器该网页是从哪个页面链接过来的）\n * 使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token\n   ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie\n   单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个\n   token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session\n   中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n * 对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从\n   cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie\n   中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比\n   CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS\n   漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n * 在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite\n   一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是\n   GET 请求，且会发生页面跳转的请求所使用。\n\n\nSQL注入有哪几种注入类型？#\n\n从注入参数类型分：数字型注入、字符型注入、搜索型注入\n\n从注入方法分：基于报错、基于布尔盲注、基于时间盲注、联合查询、堆叠注入、内联查询注入、宽字节注入\n\n从提交方式分：GET注入、POST注入、COOKIE注入、HTTP头注入","frontmatter":{},"version":""}]